<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Rust.AST</name></assembly>
<members>
<member name="M:Fable.Transforms.Rust.AST.Spans.Ident.with_dummy_span(System.String)">
<summary>
 Constructs a new identifier with a dummy span.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Spans.Ident.new_(System.String,Fable.Transforms.Rust.AST.Spans.Span)">
<summary>
 Constructs a new identifier from a symbol and a span.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Spans.Ident.from_str_and_span(System.String,Fable.Transforms.Rust.AST.Spans.Span)">
<summary>
 Maps a string and a span to an identifier.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Spans.Ident.from_str(System.String)">
<summary>
 Maps a string to an identifier with a dummy span.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Spans.SpanData.ctxt">
<summary>
 Information about where the macro came from, if this piece of
 code was created by a macro expansion.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ForeignItemKind.MacCall">
<summary>
 A macro expanding to foreign items.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ForeignItemKind.TyAlias">
<summary>
 An foreign type.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ForeignItemKind.Fn">
<summary>
 An foreign function.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ForeignItemKind.Static">
<summary>
 A foreign static item (`static FOO: u8`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ForeignItemKind">
<summary>
 An item in `extern` block.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocItemKind.MacCall">
<summary>
 A macro expanding to associated items.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocItemKind.TyAlias">
<summary>
 An associated type.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocItemKind.Fn">
<summary>
 An associated function.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocItemKind.Const">
<summary>
 An associated constant, `const $ident: $ty $def?;` where `def ::= &quot;=&quot; $expr? ;`.
 If `def` is parsed, then the constant is provided, and otherwise required.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocItemKind">
<summary>
 Represents associated item kinds.

 The term &quot;provided&quot; in the variants below refers to the item having a default
 definition / body. Meanwhile, a &quot;required&quot; item lacks a definition / body.
 In an implementation, all items must be provided.
 The `Option`s below denote the bodies, where `Some(_)`
 means &quot;provided&quot; and conversely `None` means &quot;required&quot;.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocItem">
<summary>
 Represents associated items.
 These include items in `impl` and `trait` definitions.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.MacroDef">
<summary>
 A macro definition.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.MacCall">
<summary>
 A macro invocation.

 E.g., `foo!(..)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Impl">
<summary>
 An implementation.

 E.g., `impl&lt;A&gt; Foo&lt;A&gt; { .. }` or `impl&lt;A&gt; Trait for Foo&lt;A&gt; { .. }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.TraitAlias">
<summary>
 Trait alias

 E.g., `trait Foo = Bar + Quux;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Trait">
<summary>
 A trait declaration (`trait`).

 E.g., `trait Foo { .. }`, `trait Foo&lt;T&gt; { .. }` or `auto trait Foo {}`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Union">
<summary>
 A union definition (`union`).

 E.g., `union Foo&lt;A, B&gt; { x: A, y: B }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Struct">
<summary>
 A struct definition (`struct`).

 E.g., `struct Foo&lt;A&gt; { x: A }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Enum">
<summary>
 An enum definition (`enum`).

 E.g., `enum Foo&lt;A, B&gt; { C&lt;A&gt;, D&lt;B&gt; }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.TyAlias">
<summary>
 A type alias (`type`).

 E.g., `type Foo = Bar&lt;u8&gt;;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.GlobalAsm">
<summary>
 Module-level inline assembly (from `global_asm!()`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.ForeignMod">
<summary>
 An external module (`extern`).

 E.g., `extern {}` or `extern &quot;C&quot; {}`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Mod">
<summary>
 A module declaration (`mod`).

 E.g., `mod foo;` or `mod foo { .. }`.
 `unsafe` keyword on modules is accepted syntactically for macro DSLs, but not
 semantically by Rust.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Fn">
<summary>
 A function declaration (`fn`).

 E.g., `fn foo(bar: usize) -&gt; usize { .. }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Const">
<summary>
 A constant item (`const`).

 E.g., `const FOO: i32 = 42;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Static">
<summary>
 A static item (`static`).

 E.g., `static FOO: i32 = 42;` or `static FOO: &amp;&apos;static str = &quot;bar&quot;;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.Use">
<summary>
 A use declaration item (`use`).

 E.g., `use foo;`, `use foo::bar;` or `use foo::bar as FooBar;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ItemKind.ExternCrate">
<summary>
 An `extern crate` item, with the optional *original* crate name if the crate was renamed.

 E.g., `extern crate foo` or `extern crate foo_bar as foo`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.ImplKind.of_trait">
<summary>
 The trait being implemented, if any.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.FnHeader">
<summary>
 A function header.

 All the information between the visibility and the name of the function is
 included in this struct (e.g., `async unsafe fn` or `const extern &quot;C&quot; fn`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Extern">
<summary>
 `extern` qualifier on a function item or function type.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Item`1.tokens">
<summary>
 Original tokens this item was parsed from. This isn&apos;t necessarily
 available for all items, although over time more and more items should
 have this be `Some`. Right now this is primarily used for procedural
 macros, notably custom attributes.

 Note that the tokens here do not include the outer attributes, but will
 include inner attributes.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Item`1.ident">
<summary>
 The name of the item.
 It might be a dummy name in case of anonymous items.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Item`1">
<summary>
 An item definition.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.VariantData.Unit">
<summary>
 Unit variant.

 E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.VariantData.Tuple">
<summary>
 Tuple variant.

 E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.VariantData.Struct">
<summary>
 Struct variant.

 E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.VariantData">
<summary>
 Fields and constructor ids of enum variants and structs.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.FieldDef">
<summary>
 Field definition in a struct, variant or union.

 E.g., `bar: usize` as in `struct Foo { bar: usize }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.CrateSugar.JustCrate">
<summary>
 Source is (just) `crate`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.CrateSugar.PubCrate">
<summary>
 Source is `pub(crate)`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.PolyTraitRef.trait_ref">
<summary>
 The `Foo&lt;&amp;&apos;a T&gt;` in `&lt;&apos;a&gt; Foo&lt;&amp;&apos;a T&gt;`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.PolyTraitRef.bound_generic_params">
<summary>
 The `&apos;a` in `&lt;&apos;a&gt; Foo&lt;&amp;&apos;a T&gt;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitRef">
<summary>
 `TraitRef`s appear in impls.

 Resolution maps each `TraitRef`&apos;s `ref_id` to its defining trait; that&apos;s all
 that the `ref_id` is for. The `impl_id` maps to the &quot;self type&quot; of this impl.
 If this impl is an `ItemKind::Impl`, the `impl_id` is redundant (it could be the
 same as the impl&apos;s `NodeId`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AttrKind.DocComment">
<summary>
 A doc comment (e.g. `/// ...`, `//! ...`, `/** ... */`, `/*! ... */`).
 Doc attributes (e.g. `#[doc=&quot;...&quot;]`) are represented with the `Normal`
 variant (which is much less compact and thus more expensive).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AttrKind.Normal">
<summary>
 A normal attribute.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Attribute.style">
<summary>
 Denotes if the attribute decorates the following construct (outer)
 or the construct this attribute is contained within (inner).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Attribute">
<summary>
 Metadata associated with an item.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AttrVec">
<summary>
 A list of attributes.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AttrStyle">
<summary>
 Distinguishes between `Attribute`s that decorate items and Attributes that
 are contained as statements within items. These two cases need to be
 distinguished for pretty-printing.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UseTree">
<summary>
 A tree of paths sharing common prefixes.
 Used in `use` items both at top-level and inside of braces in import groups.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UseTreeKind.Glob">
<summary>
 `use prefix::*`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UseTreeKind.Nested">
<summary>
 `use prefix::{...}`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UseTreeKind.Simple">
<summary>
 `use prefix` or `use prefix as rename`

 The extra `NodeId`s are for HIR lowering, when additional statements are created for each
 namespace.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UseTreeKind">
<summary>
 Part of `use` item to the right of its prefix.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.is_placeholder">
<summary>
 Is a macro placeholder
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.disr_expr">
<summary>
 Explicit discriminant, e.g., `Foo = 1`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.data">
<summary>
 Fields and constructor id of the variant.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.ident">
<summary>
 Name of the variant.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.vis">
<summary>
 The visibility of the variant. Syntactically accepted but not semantically.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.span">
<summary>
 Span
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.id">
<summary>
 Id of the variant (not the constructor, see `VariantData::ctor_id()`).
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Variant.attrs">
<summary>
 Attributes of the variant.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Variant">
<summary>
 Enum variant.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GlobalAsm">
<summary>
 Global inline assembly.

 Also known as &quot;module-level assembly&quot; or &quot;file-scoped assembly&quot;.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.ForeignMod.unsafety">
<summary>
 `unsafe` keyword accepted syntactically for macro DSLs, but not
 semantically by Rust.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ForeignMod">
<summary>
 Foreign module declaration.

 E.g., `extern { .. }` or `extern &quot;C&quot; { .. }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ModKind.Unloaded">
<summary>
 Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ModKind.Loaded">
<summary>
 Module with inlined definition `mod foo { ... }`
 or with definition outlined to a separate file `mod foo;` and already loaded from it.
 The inner span is from the first token past `{` to the last token until `}`
 or from the first to the last token in the loaded file.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ModKind">
<summary>
 Module item kind.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.FnRetTy.Ty">
<summary>
 Everything else.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.FnRetTy.Default">
<summary>
 Returns type is not specified.

 Functions default to `()` and closures default to inference.
 Span points to where return type would be inserted.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ImplPolarity.Negative">
<summary>
 `impl !Trait for Type`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ImplPolarity.Positive">
<summary>
 `impl Trait for Type`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Defaultness">
<summary>
 Item defaultness.
 For details see the [RFC #2532](https://github.com/rust-lang/rfcs/pull/2532).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.IsAuto">
<summary>
 Is the trait definition an auto trait?
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.FnDecl">
<summary>
 A signature (not the body) of a function declaration.

 E.g., `fn foo(bar: baz)`.

 Please note that it&apos;s different from `FnHeader` structure
 which contains metadata about function safety, asyncness, constness and ABI.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.SelfKind.Explicit">
<summary>
 `self: TYPE`, `mut self: TYPE`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.SelfKind.Region">
<summary>
 `&amp;&apos;lt self`, `&amp;&apos;lt mut self`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.SelfKind.Value">
<summary>
 `self`, `mut self`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.SelfKind">
<summary>
 Alternative representation for `Arg`s describing `self` parameter of methods.

 E.g., `&amp;mut self` as in `fn foo(&amp;mut self)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Param">
<summary>
 A parameter in a function header.

 E.g., `bar: usize` as in `fn foo(bar: usize)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LlvmInlineAsm">
<summary>
 LLVM-style inline assembly.

 E.g., `llvm_asm!(&quot;NOP&quot;);`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LlvmInlineAsmOutput">
<summary>
 LLVM-style inline assembly.

 E.g., `&quot;={eax}&quot;(result)` as in `llvm_asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LlvmAsmDialect">
<summary>
 Inline assembly dialect.

 E.g., `&quot;intel&quot;` as in `llvm_asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.InlineAsm">
<summary>
 Inline assembly.

 E.g., `asm!(&quot;NOP&quot;);`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.InlineAsmOperand">
<summary>
 Inline assembly operand.

 E.g., `out(&quot;eax&quot;) result` as in `asm!(&quot;mov eax, 2&quot;, out(&quot;eax&quot;) result)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.InlineAsmRegOrRegClass">
<summary>
 Inline assembly operand explicit register or register class.

 E.g., `&quot;eax&quot;` as in `asm!(&quot;mov eax, 2&quot;, out(&quot;eax&quot;) result)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitObjectSyntax">
<summary>
 Syntax used to declare a trait object.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.EmitTypeExpression">
<summary>
 Escape hatch to allow adding custom macros - This is not in the core rust AST - Use with caution!!!
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.CVarArgs">
<summary>
 Placeholder for a `va_list`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Err">
<summary>
 Placeholder for a kind that has failed to be defined.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.MacCall">
<summary>
 A macro in the type position.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.ImplicitSelf">
<summary>
 Inferred type of a `self` or `&amp;self` argument in a method.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Infer">
<summary>
 This means the type should be inferred instead of it having been
 specified. This can appear anywhere in a type.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Typeof">
<summary>
 Unused for now.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Paren">
<summary>
 No-op; kept solely so that we can pretty-print faithfully.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.ImplTrait">
<summary>
 An `impl Bound1 + Bound2 + Bound3` type
 where `Bound` is a trait or a lifetime.

 The `NodeId` exists to prevent lowering from having to
 generate `NodeId`s on the fly, which would complicate
 the generation of opaque `type Foo = impl Trait` items significantly.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.TraitObject">
<summary>
 A trait object type `Bound1 + Bound2 + Bound3`
 where `Bound` is a trait or a lifetime.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Path">
<summary>
 A path (`module::module::...::Type`), optionally
 &quot;qualified&quot;, e.g., `&lt;Vec&lt;T&gt; as SomeTrait&gt;::SomeType`.

 Type parameters are stored in the `Path` itself.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Tup">
<summary>
 A tuple (`(A, B, C, D,...)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Never">
<summary>
 The never type (`!`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.BareFn">
<summary>
 A bare function (e.g., `fn(usize) -&gt; bool`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Rptr">
<summary>
 A reference (`&amp;&apos;a T` or `&amp;&apos;a mut T`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Ptr">
<summary>
 A raw pointer (`*const T` or `*mut T`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Array">
<summary>
 A fixed length array (`[T; n]`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind.Slice">
<summary>
 A variable-length slice (`[T]`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TyKind">
<summary>
 The various kinds of type recognized by the compiler.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocTyConstraintKind.Bound">
<summary>
 E.g. `A: TraitA + TraitB` in `Foo&lt;A: TraitA + TraitB&gt;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocTyConstraintKind.Equality">
<summary>
 E.g., `A = Bar` in `Foo&lt;A = Bar&gt;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocTyConstraintKind">
<summary>
 The kinds of an `AssocTyConstraint`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AssocTyConstraint">
<summary>
 A constraint on an associated type (e.g., `A = Bar` in `Foo&lt;A = Bar&gt;` or
 `A: TraitA + TraitB` in `Foo&lt;A: TraitA + TraitB&gt;`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.FnSig">
<summary>
 Represents a function&apos;s signature in a trait declaration,
 trait implementation, or free function.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Err">
<summary>
 Placeholder for a literal that wasn&apos;t well-formed in some way.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Bool">
<summary>
 A boolean literal.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Float">
<summary>
 A float literal (`1f64` or `1E10f64`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Int">
<summary>
 An integer literal (`1`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Char">
<summary>
 A character literal (`&apos;a&apos;`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Byte">
<summary>
 A byte char (`b&apos;f&apos;`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.ByteStr">
<summary>
 A byte string (`b&quot;foo&quot;`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind.Str">
<summary>
 A string literal (`&quot;foo&quot;`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitKind">
<summary>
 Literal kind.

 E.g., `&quot;foo&quot;`, `42`, `12.34`, or `bool`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitFloatType.Unsuffixed">
<summary>
 A float literal without a suffix (`1.0 or 1.0E10`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitFloatType.Suffixed">
<summary>
 A float literal with a suffix (`1f32` or `1E10f32`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitFloatType">
<summary>
 Type of the float literal based on provided suffix.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitIntType.Unsuffixed">
<summary>
 e.g. `42`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitIntType.Unsigned">
<summary>
 e.g. `42_u32`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitIntType.Signed">
<summary>
 e.g. `42_i32`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.LitIntType">
<summary>
 Type of the integer literal based on provided suffix.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.StrLit.symbol_unescaped">
<summary>
 The unescaped &quot;semantic&quot; representation of the literal lowered from the original token.
 FIXME: Remove this and only create the semantic representation during lowering to HIR.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.StrLit.style">
<summary>
 The original literal token as written in source code.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StrLit">
<summary>
 Same as `Lit`, but restricted to string literals.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Lit.kind">
<summary>
 The &quot;semantic&quot; representation of the literal lowered from the original tokens.
 Strings are unescaped, hexadecimal forms are eliminated, etc.
 FIXME: Remove this and only create the semantic representation during lowering to HIR.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Lit.token">
<summary>
 The original literal token as written in source code.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Lit">
<summary>
 An AST literal.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StrStyle.Raw">
<summary>
 A raw string, like `r##&quot;foo&quot;##`.

 The value is the number of `#` symbols used.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StrStyle.Cooked">
<summary>
 A regular string, like `&quot;foo&quot;`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.MacroDef.macro_rules">
<summary>
 `true` if macro was defined with `macro_rules`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacroDef">
<summary>
 Represents a macro definition.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.MacArgs.Eq.Item2">
<summary>
 &quot;value&quot; as a nonterminal token.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.MacArgs.Eq.Item1">
<summary>
 Span of the `=` token.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacArgs.Eq">
<summary>
 Arguments of a key-value attribute - `#[attr = &quot;value&quot;]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacArgs.Delimited">
<summary>
 Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacArgs.Empty">
<summary>
 No arguments - `#[attr]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacArgs">
<summary>
 Arguments passed to an attribute or a function-like macro.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacCall">
<summary>
 Represents a macro invocation. The `path` indicates which macro
 is being invoked, and the `args` are arguments passed to it.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Movability.Movable">
<summary>
 Must not contain self-references, `Unpin`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Movability.Static">
<summary>
 May contain self-references, `!Unpin`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Movability">
<summary>
 The movability of a generator / closure literal:
 whether a generator contains self-references, causing it to be `!Unpin`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.CaptureBy.Ref">
<summary>
 `move` keyword was not specified.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.CaptureBy.Value">
<summary>
 `move |x| y + x`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.CaptureBy">
<summary>
 A capture clause used in closures and `async` blocks.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.QSelf.path_span">
<summary>
 The span of `a::b::Trait` in a path like `&lt;Vec&lt;T&gt; as
 a::b::Trait&gt;::AssociatedItem`; in the case where `position ==
 0`, this is an empty span.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.QSelf">
<summary>
 The explicit `Self` type in a &quot;qualified path&quot;. The actual
 path, including the trait and the associated item, is stored
 separately. `position` represents the index of the associated
 item qualified with this `Self` type.

 ```ignore (only-for-syntax-highlight)
 &lt;Vec&lt;T&gt; as a::b::Trait&gt;::AssociatedItem
  ^~~~~     ~~~~~~~~~~~~~~^
  ty        position = 3

 &lt;Vec&lt;T&gt;&gt;::AssociatedItem
  ^~~~~    ^
  ty       position = 0
 ```
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.EmitExpression">
<summary>
 Escape hatch to allow adding custom macros - This is *not* in the core rust AST - Use with caution!!!
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Err">
<summary>
 Placeholder for an expression that wasn&apos;t syntactically well formed in some way.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Yield">
<summary>
 A `yield`, with an optional value to be yielded.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Try">
<summary>
 A try expression (`expr?`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Paren">
<summary>
 No-op: used solely so we can pretty-print faithfully.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Repeat">
<summary>
 An array literal constructed from one repeated element.

 E.g., `[1; 5]`. The expression is the element to be
 repeated; the constant is the number of times to repeat it.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Struct">
<summary>
 A struct literal expression.

 E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. rest}`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.MacCall">
<summary>
 A macro invocation; pre-expansion.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.LlvmInlineAsm">
<summary>
 Output of the `llvm_asm!()` macro.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.InlineAsm">
<summary>
 Output of the `asm!()` macro.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Ret">
<summary>
 A `return`, with an optional value to be returned.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Continue">
<summary>
 A `continue`, with an optional label.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Break">
<summary>
 A `break`, with an optional label to break, and an optional expression.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.AddrOf">
<summary>
 A referencing operation (`&amp;a`, `&amp;mut a`, `&amp;raw const a` or `&amp;raw mut a`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Path">
<summary>
 Variable reference, possibly containing `::` and/or type
 parameters (e.g., `foo::bar::&lt;baz&gt;`).

 Optionally &quot;qualified&quot; (e.g., `&lt;Vec&lt;T&gt; as SomeTrait&gt;::SomeType`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Underscore">
<summary>
 An underscore, used in destructuring assignment to ignore a value.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Range">
<summary>
 A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assignment).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Index">
<summary>
 An indexing operation (e.g., `foo[2]`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Field">
<summary>
 Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.AssignOp">
<summary>
 An assignment with an operator.

 E.g., `a += 1`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Assign">
<summary>
 An assignment (`a = foo()`).
 The `Span` argument is the span of the `=` token.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.TryBlock">
<summary>
 A try block (`try { ... }`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Await">
<summary>
 An await expression (`my_future.await`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Async">
<summary>
 An async block (`async move { ... }`).

 The `NodeId` is the `NodeId` for the closure that results from
 desugaring an async block, just like the NodeId field in the
 `Async::Yes` variant. This is necessary in order to create a def for the
 closure which can be used as a parent of any child defs. Defs
 created during lowering cannot be made the parent of any other
 preexisting defs.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Block">
<summary>
 A block (`&apos;label: { ... }`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Closure">
<summary>
 A closure (e.g., `move |a, b, c| a + b + c`).

 The final span is the span of the argument block `|...|`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Match">
<summary>
 A `match` block.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Loop">
<summary>
 Conditionless loop (can be exited with `break`, `continue`, or `return`).

 `&apos;label: loop { block }`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.ForLoop">
<summary>
 A `for` loop, with an optional label.

 `&apos;label: for pat in expr { block }`

 This is desugared to a combination of `loop` and `match` expressions.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.While">
<summary>
 A while loop, with an optional label.

 `&apos;label: while expr { block }`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.If">
<summary>
 An `if` block, with an optional `else` block.

 `if expr { block } else { expr }`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Let">
<summary>
 A `let pat = expr` expression that is only semantically allowed in the condition
 of `if` / `while` expressions. (e.g., `if let 0 = x { .. }`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Type">
<summary>
 A type ascription (e.g., `42: usize`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Cast">
<summary>
 A cast (e.g., `foo as f64`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Lit">
<summary>
 A literal (e.g., `1`, `&quot;foo&quot;`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Unary">
<summary>
 A unary operation (e.g., `!x`, `*x`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Binary">
<summary>
 A binary operation (e.g., `a + b`, `a * b`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Tup">
<summary>
 A tuple (e.g., `(a, b, c, d)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.MethodCall">
<summary>
 A method call (`x.foo::&lt;&apos;static, Bar, Baz&gt;(a, b, c, d)`)

 The `PathSegment` represents the method name and its generic arguments
 (within the angle brackets).
 The first element of the vector of an `Expr` is the expression that evaluates
 to the object on which the method is being called on (the receiver)
 and the remaining elements are the rest of the arguments.
 Thus, `x.foo::&lt;Bar, Baz&gt;(a, b, c, d)` is represented as
 `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.
 This `Span` is the span of the function, without the dot and receiver
 (e.g. `foo(a, b)` in `x.foo(a, b)`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Call">
<summary>
 A function call

 The first field resolves to the function itself
 and the second field is the list of arguments.
 This also represents calling the constructor of
 tuple-like ADTs such as tuple structs and enum variants.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.ConstBlock">
<summary>
 Allow anonymous constants from an inline `const` block
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Array">
<summary>
 An array (`[a, b, c, d]`)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprKind.Box">
<summary>
 A `box x` expression.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StructRest.None">
<summary>
 No trailing `..` or expression.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StructRest.Rest">
<summary>
 `..`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StructRest.Base">
<summary>
 `..x`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.RangeLimits.Closed">
<summary>
 Inclusive at the beginning and end
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.RangeLimits.HalfOpen">
<summary>
 Inclusive at the beginning, exclusive at the end
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.RangeLimits">
<summary>
 Limit types of a range (inclusive or exclusive)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Expr">
<summary>
 An expression.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AnonConst">
<summary>
 A constant (expression) that&apos;s not an item or associated item,
 but needs its own `DefId` for type-checking, const-eval, etc.
 These are usually found nested inside types (e.g., array lengths)
 or expressions (e.g., repeat counts), and also used to define
 explicit discriminant values for enum variants.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ExprField">
<summary>
 A single field in a struct expression, e.g. `x: value` and `y` in `Foo { x: value, y }`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Arm.body">
<summary>
 Match arm body.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Arm.guard">
<summary>
 Match arm guard, e.g. `n &gt; 10` in `match foo { n if n &gt; 10 =&gt; {}, _ =&gt; {} }`
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Arm.pat">
<summary>
 Match arm pattern, e.g. `10` in `match foo { 10 =&gt; {}, _ =&gt; {} }`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Arm">
<summary>
 An arm of a &apos;match&apos;.

 E.g., `0..=10 =&gt; { println!(&quot;match!&quot;) }` as in

 ```
 match 123 {
     0..=10 =&gt; { println!(&quot;match!&quot;) },
     _ =&gt; { println!(&quot;no match!&quot;) },
 }
 ```
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Local.init">
<summary>
 Initializer expression to set the value, if any.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Local">
<summary>
 Local represents a `let` statement, e.g., `let &lt;pat&gt;:&lt;ty&gt; = &lt;expr&gt;;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacStmtStyle.NoBraces">
<summary>
 The macro statement had parentheses or brackets and no semicolon (e.g.
 `foo!(...)`). All of these will end up being converted into macro
 expressions.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacStmtStyle.Braces">
<summary>
 The macro statement had braces (e.g., `foo! { ... }`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MacStmtStyle.Semicolon">
<summary>
 The macro statement had a trailing semicolon (e.g., `foo! { ... };`
 `foo!(...);`, `foo![...];`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StmtKind.MacCall">
<summary>
 Macro.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StmtKind.Empty">
<summary>
 Just a trailing semi-colon.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StmtKind.Semi">
<summary>
 Expr with a trailing semi-colon.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StmtKind.Expr">
<summary>
 Expr without trailing semi-colon.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StmtKind.Item">
<summary>
 An item definition.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.StmtKind.Local">
<summary>
 A local (let) binding.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Stmt">
<summary>
 A statement
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UnOp.Neg">
<summary>
 The `-` operator for negation
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UnOp.Not">
<summary>
 The `!` operator for logical inversion
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UnOp.Deref">
<summary>
 The `*` operator for dereferencing
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.UnOp">
<summary>
 Unary operator.

 Note that `&amp;data` is not an operator, it&apos;s an `AddrOf` expression.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Gt">
<summary>
 The `&gt;` operator (greater than)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Ge">
<summary>
 The `&gt;=` operator (greater than or equal to)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Ne">
<summary>
 The `!=` operator (not equal to)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Le">
<summary>
 The `&lt;=` operator (less than or equal to)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Lt">
<summary>
 The `&lt;` operator (less than)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Eq">
<summary>
 The `==` operator (equality)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Shr">
<summary>
 The `&gt;&gt;` operator (shift right)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Shl">
<summary>
 The `&lt;&lt;` operator (shift left)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.BitOr">
<summary>
 The `|` operator (bitwise or)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.BitAnd">
<summary>
 The `&amp;` operator (bitwise and)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.BitXor">
<summary>
 The `^` operator (bitwise xor)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Or">
<summary>
 The `||` operator (logical or)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.And">
<summary>
 The `&amp;&amp;` operator (logical and)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Rem">
<summary>
 The `%` operator (modulus)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Div">
<summary>
 The `/` operator (division)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Mul">
<summary>
 The `*` operator (multiplication)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Sub">
<summary>
 The `-` operator (subtraction)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BinOpKind.Add">
<summary>
 The `+` operator (addition)
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BorrowKind.Raw">
<summary>
 A raw borrow, `&amp;raw const $expr` or `&amp;raw mut $expr`.
 The resulting type is either `*const T` or `*mut T`
 where `T = typeof($expr)`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BorrowKind.Ref">
<summary>
 A normal borrow, `&amp;$expr` or `&amp;mut $expr`.
 The resulting type is either `&amp;&apos;a T` or `&amp;&apos;a mut T`
 where `T = typeof($expr)` and `&apos;a` is some lifetime.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.BorrowKind">
<summary>
 The kind of borrow in an `AddrOf` expression,
 e.g., `&amp;place` or `&amp;raw const place`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.MacCall">
<summary>
 A macro pattern; pre-expansion.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Paren">
<summary>
 Parentheses in patterns used for grouping (i.e., `(PAT)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Rest">
<summary>
 A rest pattern `..`.

 Syntactically it is valid anywhere.

 Semantically however, it only has meaning immediately inside:
 - a slice pattern: `[a, .., b]`
 - a binding pattern immediately inside a slice pattern: `[a, r @ ..]`
 - a tuple pattern: `(a, .., b)`
 - a tuple struct/variant pattern: `$path(a, .., b)`.

 In all of these cases, an additional restriction applies
 only one rest pattern may occur in the pattern sequences.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Slice">
<summary>
 A slice pattern `[a, b, c]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Range">
<summary>
 A range pattern (e.g., `1...2`, `1..=2` or `1..2`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Lit">
<summary>
 A literal.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Ref">
<summary>
 A reference pattern (e.g., `&amp;mut (a, b)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Box">
<summary>
 A `box` pattern.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Tuple">
<summary>
 A tuple pattern (`(a, b)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Path">
<summary>
 A possibly qualified path pattern.
 Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants
 or associated constants. Qualified path patterns `&lt;A&gt;::B::C`/`&lt;A as Trait&gt;::B::C` can
 only legally refer to associated constants.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Or">
<summary>
 An or-pattern `A | B | C`.
 Invariant: `pats.len() &gt;= 2`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.TupleStruct">
<summary>
 A tuple struct/variant pattern (`Variant(x, y, .., z)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Struct">
<summary>
 A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).
 The `bool` is `true` in the presence of a `..`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Ident">
<summary>
 A `PatKind::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`)
 or a unit struct/variant pattern, or a const pattern (in the last two cases the third
 field must be `None`). Disambiguation cannot be done with parser alone, so it happens
 during name resolution.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatKind.Wild">
<summary>
 Represents a wildcard pattern (`_`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.RangeSyntax.DotDotEq">
<summary>
 `..=`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.RangeSyntax.DotDotDot">
<summary>
 `...`
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.PatField.pat">
<summary>
 The pattern the field is destructured to.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.PatField.ident">
<summary>
 The identifier for the field.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PatField">
<summary>
 A single field in a struct pattern.

 Patterns like the fields of `Foo { x, ref y, ref mut z }`
 are treated the same as `x: x, y: ref y, z: ref mut z`,
 except when `is_shorthand` is true.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Pat">
<summary>
 A match pattern.

 Patterns appear in match statements and some other contexts, such as `let` and `if let`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Block.rules">
<summary>
 Distinguishes between `unsafe { ... }` and `{ ... }`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Block.stmts">
<summary>
 The statements in the block.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Block">
<summary>
 A block (`{ .. }`).

 E.g., `{ .. }` as in `fn foo() { .. }`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MetaItemKind.NameValue">
<summary>
 Name value meta item.

 E.g., `feature = &quot;foo&quot;` as in `#[feature = &quot;foo&quot;]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MetaItemKind.List">
<summary>
 List meta item.

 E.g., `derive(..)` as in `#[derive(..)]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MetaItemKind.Word">
<summary>
 Word meta item.

 E.g., `test` as in `#[test]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MetaItemKind">
<summary>
 A compile-time attribute item.

 E.g., `#[test]`, `#[derive(..)]` or `#[feature = &quot;foo&quot;]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.MetaItem">
<summary>
 A spanned compile-time attribute item.

 E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = &quot;foo&quot;]`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.NestedMetaItem.Literal">
<summary>
 A literal.

 E.g., `&quot;foo&quot;`, `64`, `true`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.NestedMetaItem.MetaItem">
<summary>
 A full MetaItem, for recursive meta items.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.NestedMetaItem">
<summary>
 Possible values inside of compile-time attribute lists.

 E.g., the &apos;..&apos; in `#[name(..)]`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Crate.proc_macros">
<summary>
 The order of items in the HIR is unrelated to the order of
 items in the AST. However, we generate proc macro harnesses
 based on the AST order, and later refer to these harnesses
 from the HIR. This field keeps track of the order in which
 we generated proc macros harnesses, so that we can map
 HIR proc macros items back to their harness items.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WhereEqPredicate">
<summary>
 An equality predicate (unsupported).

 E.g., `T = int`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WhereRegionPredicate">
<summary>
 A lifetime predicate.

 E.g., `&apos;a: &apos;b + &apos;c`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.WhereBoundPredicate.bounds">
<summary>
 Trait and lifetime bounds (`Clone + Send + &apos;static`).
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.WhereBoundPredicate.bounded_ty">
<summary>
 The type being bounded.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.WhereBoundPredicate.bound_generic_params">
<summary>
 Any generics from a `for` binding.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WhereBoundPredicate">
<summary>
 A type bound.

 E.g., `for&lt;&apos;c&gt; Foo: Send + Clone + &apos;c`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WherePredicate.EqPredicate">
<summary>
 An equality predicate (unsupported).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WherePredicate.RegionPredicate">
<summary>
 A lifetime predicate (e.g., `&apos;a: &apos;b + &apos;c`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WherePredicate.BoundPredicate">
<summary>
 A type binding (e.g., `for&lt;&apos;c&gt; Foo: Send + Clone + &apos;c`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WherePredicate">
<summary>
 A single predicate in a where-clause.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.WhereClause.has_where_token">
<summary>
 `true` if we ate a `where` token: this can happen
 if we parsed no predicates (e.g. `struct Foo where {}`).
 This allows us to accurately pretty-print
 in `nt_to_tokenstream`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.WhereClause">
<summary>
 A where-clause in a definition.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Generics">
<summary>
 Represents lifetime, type and const parameters attached to a declaration of
 a function, enum, trait, etc.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.GenericParamKind.Const.default_">
<summary>
 Optional default value for the const generic param
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.GenericParamKind.Const.kw_span">
<summary>
 Span of the `const` keyword.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericParamKind.Lifetime">
<summary>
 A lifetime definition (e.g., `&apos;a: &apos;b + &apos;c + &apos;d`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ParamKindOrd">
<summary>
 Specifies the enforced ordering for generic parameters. In the future,
 if we wanted to relax this order, we could override `PartialEq` and
 `PartialOrd`, to allow the kinds to be unordered.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericBound">
<summary>
 The AST represents all type param bounds as types.
 `typeck::collect::compute_bounds` matches these against
 the &quot;special&quot; built-in traits (see `middle::lang_items`) and
 detects `Copy`, `Send` and `Sync`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitBoundModifier.MaybeConstMaybe">
<summary>
 `?const ?Trait`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitBoundModifier.MaybeConst">
<summary>
 `?const Trait`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitBoundModifier.Maybe">
<summary>
 `?Trait`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitBoundModifier.None">
<summary>
 No modifiers
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.TraitBoundModifier">
<summary>
 A modifier on a bound, e.g., `?Sized` or `?const Trait`.

 Negative bounds should also be handled here.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.ParenthesizedArgs.output">
<summary>
 `C`
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.ParenthesizedArgs.inputs_span">
<summary>
 ```text
 Foo(A, B) -&gt; C
    ^^^^^^
 ```
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.ParenthesizedArgs.inputs">
<summary>
 `(A, B)`
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.ParenthesizedArgs.span">
<summary>
 ```text
 Foo(A, B) -&gt; C
 ^^^^^^^^^^^^^^
 ```
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.ParenthesizedArgs">
<summary>
 A path like `Foo(A, B) -&gt; C`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AngleBracketedArg.Constraint">
<summary>
 Constraint for an associated item.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AngleBracketedArg.Arg">
<summary>
 Argument for a generic parameter.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AngleBracketedArg">
<summary>
 Either an argument for a parameter e.g., `&apos;a`, `Vec&lt;u8&gt;`, `0`,
 or a constraint on an associated item, e.g., `Item = String` or `Item: Bound`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.AngleBracketedArgs.args">
<summary>
 The comma separated parts in the `&lt;...&gt;`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.AngleBracketedArgs.span">
<summary>
 The overall span.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.AngleBracketedArgs">
<summary>
 A path like `Foo&lt;&apos;a, T&gt;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArg.Const">
<summary>
 `1` in `Foo&lt;1&gt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArg.Type">
<summary>
 `Bar` in `Foo&lt;Bar&gt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArg.Lifetime">
<summary>
 `&apos;a` in `Foo&lt;&apos;a&gt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArg">
<summary>
 Concrete argument in the sequence of generic args.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArgs.Parenthesized">
<summary>
 The `(A, B)` and `C` in `Foo(A, B) -&gt; C`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArgs.AngleBracketed">
<summary>
 The `&lt;&apos;a, A, B, C&gt;` in `foo::bar::baz::&lt;&apos;a, A, B, C&gt;`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.GenericArgs">
<summary>
 The arguments of a path segment.

 E.g., `&lt;A, B&gt;` as in `Foo&lt;A, B&gt;` or `(A, B)` as in `Foo(A, B)`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.PathSegment.args">
<summary>
 Type/lifetime parameters attached to this path. They come in
 two flavors: `Path&lt;A,B,C&gt;` and `Path(A,B) -&gt; C`.
 `None` means that no parameter list is supplied (`Path`)
 `Some` means that parameter list is supplied (`Path&lt;X, Y&gt;`)
 but it can be empty (`Path&lt;&gt;`).
 `P` is used as a size optimization for the common case with no parameters.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.PathSegment.ident">
<summary>
 The identifier portion of this path segment.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.PathSegment">
<summary>
 A segment of a path: an identifier, an optional lifetime, and a set of types.

 E.g., `std`, `String` or `Box&lt;T&gt;`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Types.Path.segments">
<summary>
 The segments in the path: the things separated by `::`.
 Global paths begin with `kw::PathRoot`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Path">
<summary>
 A &quot;Path&quot; is essentially Rust&apos;s notion of a name.

 It&apos;s represented as a sequence of identifiers,
 along with a bunch of supporting information.

 E.g., `std::cmp::PartialEq`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Lifetime">
<summary>
 A &quot;Lifetime&quot; is an annotation of the scope in which variable
 can be used, e.g. `&apos;a` in `&amp;&apos;a i32`.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.Label">
<summary>
 A &quot;Label&quot; is an identifier of some point in sources,
 e.g. in the following code:

 ```rust
 &apos;outer: loop {
     break &apos;outer;
 }
 ```

 `&apos;outer` is a label.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenStream">
<summary>
 A `TokenStream` is an abstract sequence of tokens, organized into [`TokenTree`]s.

 The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s
 instead of a representation of the abstract syntax tree.
 Today&apos;s `TokenTree`s can still contain AST via `token.Interpolated` for
 backwards compatibility.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenTree.Delimited">
<summary>
 A delimited sequence of token trees.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenTree.Token">
<summary>
 A single token.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.Nonterminal.NtMeta">
<summary>
 Stuff inside brackets for attributes
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.Nonterminal">
<summary>
 For interpolation during macro expansion.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenKind.DocComment">
<summary>
 A doc comment token.
 `Symbol` is the doc comment&apos;s data excluding its &quot;quotes&quot; (`///`, `/**`, etc)
 similarly to symbols in string literal tokens.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenKind.Lifetime">
<summary>
 Lifetime identifier token.
 Do not forget about `NtLifetime` when you want to match on lifetime identifiers.
 It&apos;s recommended to use `Token::(lifetime,uninterpolate,uninterpolated_span)` to
 treat regular and interpolated lifetime identifiers in the same way.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenKind.Ident">
<summary>
 Identifier token.
 Do not forget about `NtIdent` when you want to match on identifiers.
 It&apos;s recommended to use `Token::(ident,uninterpolate,uninterpolated_span)` to
 treat regular and interpolated identifiers in the same way.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenKind.CloseDelim">
<summary>
 A closing delimiter (e.g., `}`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenKind.OpenDelim">
<summary>
 An opening delimiter (e.g., `{`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.TokenKind.SingleQuote">
<summary>
 Used by proc macros for representing lifetimes, not generated by lexer right now.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.Lit">
<summary>
 A literal token.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.DelimToken.NoDelim">
<summary>
 An empty delimiter.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.DelimToken.Brace">
<summary>
 A curly brace (i.e., `{` or `}`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.DelimToken.Bracket">
<summary>
 A square bracket (i.e., `[` or `]`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.DelimToken.Paren">
<summary>
 A round parenthesis (i.e., `(` or `)`).
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Types.token.DelimToken">
<summary>
 A delimiter token.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.Fixity.None">
<summary>
 The operator is not associative
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.Fixity.Right">
<summary>
 The operator is right-associative
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.Fixity.Left">
<summary>
 The operator is left-associative
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Colon">
<summary>
 `:`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.DotDotEq">
<summary>
 `..=` range
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.DotDot">
<summary>
 `..` range
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.As">
<summary>
 `as`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.AssignOp">
<summary>
 `?=` where ? is one of the BinOpToken
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Assign">
<summary>
 `=`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.GreaterEqual">
<summary>
 `&gt;=`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Greater">
<summary>
 `&gt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.NotEqual">
<summary>
 `!=`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.LessEqual">
<summary>
 `&lt;=`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Less">
<summary>
 `&lt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Equal">
<summary>
 `==`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.ShiftRight">
<summary>
 `&gt;&gt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.ShiftLeft">
<summary>
 `&lt;&lt;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.BitOr">
<summary>
 `|`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.BitAnd">
<summary>
 ``
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.BitXor">
<summary>
 `^`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.LOr">
<summary>
 `||`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.LAnd">
<summary>
 `&amp;&amp;`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Modulus">
<summary>
 `%`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Divide">
<summary>
 `/`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Multiply">
<summary>
 `*`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Subtract">
<summary>
 `-`
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp.Add">
<summary>
 `+`
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.AssocOp.precedence">
<summary>
 Gets the precedence of this operator
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.AssocOp.from_ast_binop(Fable.Transforms.Rust.AST.Types.BinOpKind)">
<summary>
 Creates a new AssocOp from ast.BinOpKind.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.AssocOp.fixity">
<summary>
 Gets the fixity of this operator
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.AssocOp.can_continue_expr_unambiguously">
<summary>
 This operator could be used to follow a block unambiguously.

 This is used for error recovery at the moment, providing a suggestion to wrap blocks with
 parentheses while having a high degree of confidence on the correctness of the suggestion.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Parser.AssocOp">
<summary>
 Associative operator with precedence.

 This is the enum which specifies operator precedence and fixity to the parser.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.contains_exterior_struct_lit(Fable.Transforms.Rust.AST.Types.Expr)">
<summary>
 Expressions that syntactically contain an &quot;exterior&quot; struct literal i.e., not surrounded by any
 parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo = X { y: 1 }` and
 `X { y: 1 } = foo` all do, but `(X { y: 1 }) = foo` does not.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.needs_par_as_let_scrutinee(System.SByte)">
<summary>
 Suppose we have `let _ = e` and the `order` of `e`.
 Is the `order` such that `e` in `let _ = e` needs parenthesis when it is on the RHS?

 Conversely, suppose that we have `(let _ = a) OP b` and `order` is that of `OP`.
 Can we print this as `let _ = a OP b`?
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Parser.prec_let_scrutinee_needs_par">
<summary>
 In `let p = e`, operators with precedence `&lt;=` this one requires parenthesis in `e`.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.VariantData.ctor_id(Fable.Transforms.Rust.AST.Types.VariantData)">
<summary>
 Return the `NodeId` of this variant&apos;s constructor, if it has one.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.VariantData.fields(Fable.Transforms.Rust.AST.Types.VariantData)">
<summary>
 Return the fields of this variant.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.Asyncness.opt_return_id(Fable.Transforms.Rust.AST.Types.Asyncness)">
<summary>
 In this case this is an `async` return, the `NodeId` for the generated `impl Trait` item.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.Param.to_self(Fable.Transforms.Rust.AST.Types.Param)">
<summary>
 Attempts to cast parameter to `ExplicitSelf`.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.InlineAsmTemplatePiece.to_string.Static(System.Collections.Generic.List{Fable.Transforms.Rust.AST.Types.InlineAsmTemplatePiece})">
<summary>
 Rebuilds the asm template string from its pieces.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.MacArgs.need_semicolon(Fable.Transforms.Rust.AST.Types.MacArgs)">
<summary>
 Whether a macro with these arguments needs a semicolon
 when used as a standalone item or statement.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.MacArgs.inner_tokens(Fable.Transforms.Rust.AST.Types.MacArgs)">
<summary>
 Tokens inside the delimiters or after `=`.
 Proc macros see these tokens, for example.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.Expr.expr_requires_semi_to_be_stmt(Fable.Transforms.Rust.AST.Types.Expr)">
<summary>
 Does this expression require a semicolon to be treated
 as a statement? The negation of this: &apos;can this expression
 be used as a statement without a semicolon&apos; -- is used
 as an early-bail-out in the parser so that, for instance,
     if true then...else...}
      |x| 5
 isn&apos;t parsed as (if true then...else...} | x) | 5
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Impl.Generics.default_.Static">
<summary>
 Creates an instance of `Generics`.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.pending_indentation">
<summary>
 Buffered indentation to avoid writing trailing whitespace
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.print_stack">
<summary>
 Stack of blocks-in-progress being flushed by print
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.scan_stack">
<summary>
 Pseudo-stack, really a ring too. Holds the
 primary-ring-buffers index of the Begin that started the
 current block, possibly with the most recent Break after that
 Begin (if there is any) on top of it. Stuff is flushed off the
 bottom |&gt; it becomes irrelevant due to the primary ring-buffer
 advancing.
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.right_total">
<summary>
 Running size of stream &quot;...right&quot;
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.left_total">
<summary>
 Running size of stream &quot;...left&quot;
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.buf">
<summary>
 Ring-buffer of tokens and calculated sizes
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.right">
<summary>
 Index of right side of input stream
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.left">
<summary>
 Index of left side of input stream
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.space_left">
<summary>
 Number of spaces left on line
</summary>
</member>
<member name="P:Fable.Transforms.Rust.AST.Pretty.Printer.margin">
<summary>
 Width of lines we&apos;re constrained to
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Pretty.Printer.replace_last_token(Fable.Transforms.Rust.AST.Pretty.Token)">
<summary>
 Be very careful with this!
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Pretty.Printer.rbox(System.Int32,Fable.Transforms.Rust.AST.Pretty.Breaks)">
<summary>
 &quot;raw box&quot;
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Pretty.Printer.ibox(System.Int32)">
<summary>
 Inconsistent breaking box
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.Pretty.Printer.cbox(System.Int32)">
<summary>
 Consistent breaking box
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.Pretty.Breaks">
<summary>
 How to break. Described in more detail in the module docs.
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.Edition.Edition2021">
<summary>
 The 2021 edition
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.Edition.Edition2018">
<summary>
 The 2018 edition
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.Edition.Edition2015">
<summary>
 The 2015 edition
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.token_to_string(Fable.Transforms.Rust.AST.Types.token.Token)">
<summary>
 Print the token precisely, without converting `$crate` into its respective name.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.token_kind_to_string(Fable.Transforms.Rust.AST.Types.token.TokenKind)">
<summary>
 Print the token kind precisely, without converting `$crate` into its respective name.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.print_tt(Fable.Transforms.Rust.AST.Types.token.TokenTree,System.Boolean)">
<summary>
 This doesn&apos;t deserve to be called &quot;pretty&quot; printing, but it should be
 meaning-preserving. A quick hack that might help would be to look at the
 spans embedded in the TTs to decide where to put spaces and newlines.
 But it&apos;d be better to parse these according to the grammar of the
 appropriate macro, transcribe back into the grammar we just parsed from,
 and then pretty-print the resulting AST nodes (so, e.g., we print
 expression arguments as expressions). It can be done! I think.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.print_let(Fable.Transforms.Rust.AST.Types.Pat,Fable.Transforms.Rust.AST.Types.Expr)">
<summary>
 Print a `let pat = scrutinee` expression.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.print_item(Fable.Transforms.Rust.AST.Types.Item{Fable.Transforms.Rust.AST.Types.ItemKind})">
<summary>
 Pretty-prints an item.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.print_expr_cond_paren(Fable.Transforms.Rust.AST.Types.Expr,System.Boolean)">
<summary>
 Prints `expr` or `(expr)` when `needs_par` holds.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.print_expr_as_cond(Fable.Transforms.Rust.AST.Types.Expr)">
<summary>
 Prints an expr using syntax that&apos;s acceptable in a condition position, such as the `cond` in
 `if cond then ... }`.
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.State.cond_needs_par(Fable.Transforms.Rust.AST.Types.Expr)">
<summary>
 Does `expr` need parenthesis when printed in a condition position?
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.CommentStyle.BlankLine">
<summary>
 Just a manual blank line &quot;\n\n&quot;, for layout
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.CommentStyle.Mixed">
<summary>
 Code before /* foo */ and after the comment
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.CommentStyle.Trailing">
<summary>
 Code exists to the left of the comment
</summary>
</member>
<member name="T:Fable.Transforms.Rust.AST.State.CommentStyle.Isolated">
<summary>
 No code on either side of each line of the comment
</summary>
</member>
<member name="M:Fable.Transforms.Rust.AST.State.print_crate(Fable.Transforms.Rust.AST.State.SourceMap,Fable.Transforms.Rust.AST.Types.Crate,System.String,System.String,Fable.Transforms.Rust.AST.State.PpAnn,System.Boolean,Fable.Transforms.Rust.AST.State.Edition)">
<summary>
 Requires you to pass an input filename and reader so that
 it can scan the input text for comments to copy forward.
</summary>
</member>
</members>
</doc>
